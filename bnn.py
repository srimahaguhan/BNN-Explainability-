from pysat.pb import PBEnc
from pysat.formula import WCNF
from pysat.examples.rc2 import RC2
from pysat.solvers import Glucose3, Solver
from typing import List
import argparse

def bnn():
    pbc_list = [[[1,2,3], [1,1,1], 2, 1], [[1,2,3], [1,1,1], 1, -1], [[1,-2,3], [1,1,1], 1, 1], [[1,-2,3], [1,1,1], 0, -1], [[-1,2,3], [1,1,1], 1, 1], [[-1,2,3], [1,1,1], 0, -1], [[1,2,-3], [1,1,1], 1, 1], [[1,2,-3], [1,1,1], 0, -1], [[-1,2,-3], [1,1,1], 1, 1], [[-1,2,-3], [1,1,1], 0, -1], [[4,5,6,7,8],[1,1,1,1,1],5,1], [[4,5,6,7,8],[1,1,1,1,1],4,-1]]

    # just to ensure y <-> clauses generated by pbc
    conditional_list = [[4],[-4],[5],[-5],[6],[-6],[7],[-7],[8],[-8],[9],[-9]]

    wcnf = WCNF()
    s  = Solver()
    def conditionals(cnf: List[List[int]], pre_cond: List[int]): 
        # encoding [(v1 /\ v2 /\ ...) --> CNF] given lists [v1,v2,...] and list of clauses in CNF
        for list in cnf:
            for lit in pre_cond:
                list.append(-lit)
        

        if args.verb >= 1:
            print("conditionals",cnf.clauses)

    if args.verb >= 1:
        print(pbc_list)
        print(conditional_list)

    for i in range(0, len(pbc_list)):
        if(pbc_list[i][3] == 1): 
            pb_enc = PBEnc.atleast(pbc_list[i][0], pbc_list[i][1], top_id = 10,bound=pbc_list[i][2])
            
        elif(pbc_list[i][3] == -1):
            pb_enc = PBEnc.atmost(pbc_list[i][0], pbc_list[i][1], top_id = 10,bound=pbc_list[i][2])
    
        elif(pbc_list[i][3] == 0):
            pb_enc = PBEnc.equals(pbc_list[i][0], pbc_list[i][1], top_id = 10,bound=pbc_list[i][2])
           
        
        if args.verb >= 1:
            print("PBEnc", pb_enc.clauses)

        
        if conditional_list[i] != []:
            conditionals(pb_enc, conditional_list[i])

    
        
        
        for clause in pb_enc.clauses:
            wcnf.append(clause)
            s.add_clause(clause)
    
    features_values = [-1, 2, 3]   
    all_explanations = [] 
    try:
        '''
        9 represents the BNN output and 1, 2, 3 represents the features
        for all i, x_i \= vi -> N(X,y)
        '''
        with RC2(wcnf) as rc2:
            rc2.add_clause([9])
            for value in features_values:
                value = -1 * int(value)
                rc2.add_clause([value], weight= 1)
            for model in rc2.enumerate():
                explanation = []
                for index in range(len(features_values)):
                    if features_values[index] in model:
                        explanation.append(abs(features_values[index]))
                if args.verb >= 1:
                    print("Model recived from the maxsat", model)
                    print("corresponding explanation", explanation)
                all_explanations.append(explanation)
        
        if args.verb >= 1:
            print("all explanations got from MaxSAT is", all_explanations)


    except Exception as e:
        print(f"Error: {e}")
    
    " from the set of candidates explanation, find the correct explanations that works with all values of features:"
    
    '''
    fixing network output to be 0: by adding positive literal 9
    the idea is if is indeed an explanation then fixing it should be able to make the network True. 
    as we have added the -9 in the clauses, SAT solver should return UNSAT for the correct explanation
    '''

    s.add_clause([-9]) 
    for explanation in all_explanations:
        if not s.solve(assumptions=explanation):
            print("explanation is", explanation)






if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('--seed',type = int, help = "to fix the seed value, default 10", default=10)
    parser.add_argument('--verb', type = int, help = "higher verb ensures higher verbose = 0, 1, 2, default = 0", default= 0)

    args = parser.parse_args()
    bnn()
   